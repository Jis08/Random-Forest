# -*- coding: utf-8 -*-
"""Copy of RF.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VPgHpd5sOd4qJbXsTd7HmaUao9fLfJpo
"""

#importing libraries
import sys
import csv
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime
from sklearn.model_selection import train_test_split, cross_val_score, StratifiedKFold, learning_curve
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import (confusion_matrix, classification_report, accuracy_score,roc_curve, auc)

# Read datasets function
def read_datasets():
    """Reads user profiles from CSV files."""
    genuine_users = pd.read_csv("/content/sample_data/fusers (1).csv")
    genuine_users
    fake_users = pd.read_csv("/content/sample_data/users.csv")
    x = pd.concat([genuine_users, fake_users])
    y = [0] * len(fake_users) + [1] * len(genuine_users)
    return x, np.array(y)

#EDA / DATA CLEANING (REMOVING NULL VALUES ,FILLING NULL VALUES ,DROPING DUPLICATES)
df, y = read_datasets()
df = df.drop(columns=['protected', 'profile_background_tile', 'verified','default_profile_image', 'geo_enabled', 'utc_offset'],errors='ignore')
from sklearn.impute import SimpleImputer
imputer = SimpleImputer(strategy='most_frequent')
df['url'] = imputer.fit_transform(df[['url']]).ravel()
df['time_zone'] = imputer.fit_transform(df[['time_zone']]).ravel()
df['location'] = df['location'].fillna(method='ffill')
df['default_profile'] = imputer.fit_transform(df[['default_profile']]).ravel()
df['profile_banner_url'] = imputer.fit_transform(df[['profile_banner_url']]).ravel()
df['profile_use_background_image'] = df['profile_use_background_image'].fillna(method='bfill')
df['description'] = imputer.fit_transform(df[['description']]).ravel()
df.drop_duplicates()
df

df.isnull().sum() #checking null values count

def extract_features(x):
    # Check if color columns exist before processing
    if 'profile_sidebar_fill_color' in x.columns and 'profile_sidebar_border_color' in x.columns:
        x['lang_code'] = LabelEncoder().fit_transform(x['lang'])
        # Convert color columns to numerical representations using LabelEncoder
        for col in ['profile_sidebar_fill_color', 'profile_sidebar_border_color']:
            x[col] = LabelEncoder().fit_transform(x[col].astype(str))  # Convert to string type first if necessary
    else:
        # If color columns are missing, create them with default values (e.g., 0)
        x['profile_sidebar_fill_color'] = 0
        x['profile_sidebar_border_color'] = 0
        x['lang_code'] = LabelEncoder().fit_transform(x['lang'])
    #changing date and time(created at) into numerical
    x['created_at'] = pd.to_datetime(x['created_at'])
    x['created_at_year'] = x['created_at'].dt.year
    x['created_at_month'] = x['created_at'].dt.month
    x['created_at_day'] = x['created_at'].dt.day
    feature_columns_to_use = ['statuses_count', 'followers_count', 'friends_count', 'lang_code', 'created_at_year', 'created_at_month', 'created_at_day']
    return x[feature_columns_to_use]

#ploting confusion matrix
def plot_confusion_matrix(cm, title='Confusion matrix', cmap=plt.cm.Blues):
    target_names = ['Fake', 'Genuine']
    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(target_names))
    plt.xticks(tick_marks, target_names, rotation=45)
    plt.yticks(tick_marks, target_names)
    plt.tight_layout()
    plt.ylabel('True label')
    plt.xlabel('Predicted label')
    plt.show()

#plotting roc curve
def plot_roc_curve(y_test, y_pred_proba):
    false_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_pred_proba)
    roc_auc = auc(false_positive_rate, true_positive_rate)
    plt.title('Receiver Operating Characteristic')
    plt.plot(false_positive_rate, true_positive_rate, 'b', label=f'AUC = {roc_auc:.2f}')
    plt.legend(loc='lower right')

    plt.plot([0, 1], [0, 1], 'r--')
    plt.xlim([-0.1, 1.1])
    plt.ylim([-0.1, 1.1])
    plt.ylabel('True Positive Rate')
    plt.xlabel('False Positive Rate')
    plt.show()

#training model and applying algorithm(random forest)
def train(X_train, y_train, X_test):
    clf = RandomForestClassifier(n_estimators=5, random_state=44, oob_score=True)
    clf.fit(X_train, y_train)
    y_pred = clf.predict(X_test)
    y_pred_proba = clf.predict_proba(X_test)[:, 1]
    return y_pred, y_pred_proba, clf

print("Reading datasets...")
x, y = read_datasets()
print("Extracting features...")
x = extract_features(x)
print("Splitting datasets...")
X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=0.20, random_state=44)
print("Training the model...")
y_pred, y_pred_proba, clf = train(X_train, y_train, X_test)

#output of confusion matrix
print("Classification Accuracy on Test dataset:", accuracy_score(y_test, y_pred))
cm = confusion_matrix(y_test, y_pred)
print("Confusion Matrix:")
print(cm)
plot_confusion_matrix(cm)

cm_normalized = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
plot_confusion_matrix(cm_normalized, title='Normalized confusion matrix')

print("Classification Report:")
print(classification_report(y_test, y_pred, target_names=['Fake', 'Genuine']))

#ouput of roc curve
plot_roc_curve(y_test, y_pred_proba)

# Example test data for a single user
user_data = pd.DataFrame({
    'name': ['Davide Dellacasa'],
    'statuses_count': [203],
    'followers_count': [0 ],
    'friends_count': [0],
    'favourites_count': [14500],
    'listed_count': [52],
    'lang': ['it'],  # Language is English ("it")
    'created_at': ['Fri Apr 06 10:58:22 +0000 2007'] # add missing column with a default value
})


# Extract features
user_data_features = extract_features(user_data)

# Use the trained model to make predictions for this user
from sklearn.preprocessing import StandardScaler # import the StandardScaler class
scaler = StandardScaler()
user_data_scaled = scaler.fit_transform(user_data_features)

# Predict using the trained model
predicted_class = clf.predict(user_data_scaled) # use the variable assigned to the model

# Output the result
print(f"The user is predicted to be: {'Fake' if predicted_class[0] == 1 else 'Genuine'}")

